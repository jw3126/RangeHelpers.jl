var documenterSearchIndex = {"docs":
[{"location":"#RangeHelpers","page":"Home","title":"RangeHelpers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RangeHelpers]","category":"page"},{"location":"#RangeHelpers.RangeHelpers","page":"Home","title":"RangeHelpers.RangeHelpers","text":"RangeHelpers\n\n(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Build Status) (Image: Coverage)\n\nEver needed a range with startpoint 10, endpoint 121.7 and a step of 25? Well that is mathematically not possible, so you need to compromise. There are lots of options, you could relax the startpoint, endpoint or step. In the past doing this was annoying and prone to off-by-one-errors:\n\njulia> Base.range(10, step=25, length=round(Int, (121.7-10)/25)); # is it correct??\n\nRangeHelpers.jl aims to solve range construction headaches once and for all:\n\njulia> using RangeHelpers: range\n\njulia> using RangeHelpers\n\njulia> range(start=10, stop=121.7, step=around(25)) # compromise on step\n10.0:27.925:121.7\n\njulia> range(start=10, stop=121.7, step=below(25))  # compromise step at most 25\n10.0:22.34:121.7\n\njulia> range(start=10, stop=above(121.7), step=25)  # exact step, but allow bigger endpoint\n10:25:135\n\njulia> anchorrange(42, start=around(10), step=25, stop=around(121.7)) # make sure 42 is on the grid\n17:25:117\n\nSee the documentation for even more ways to make ranges.\n\n\n\n\n\n","category":"module"},{"location":"#RangeHelpers.anchorrange-Tuple{Any}","page":"Home","title":"RangeHelpers.anchorrange","text":"anchorrange(anchor; step, start, stop, pre, post)\n\nReturn a range, that approximately has anchor on its grid.\n\njulia> using RangeHelpers\n\njulia> anchorrange(15.5, start=above(11), step=2, stop=below(15))\n11.5:2.0:13.5\n\n\n\n\n\n","category":"method"},{"location":"#RangeHelpers.asrange","page":"Home","title":"RangeHelpers.asrange","text":"asrange(itr; check=true, atol, rtol)::AbstractRange\n\nConvert itr into a range, optionally validating the result.\n\njulia> using RangeHelpers\n\njulia> asrange([1,2,3.0])\n1.0:1.0:3.0\n\njulia> asrange([1,2,3])\n1:1:3\n\njulia> asrange(1:3)\n1:3\n\njulia> asrange([1,2,4.0])\nERROR: ArgumentError: Cannot construct range from `itr`\nitr = [1.0, 2.0, 4.0]\n[...]\n\njulia> asrange([1,2,4.0], atol=10)\n1.0:1.5:4.0\n\n\n\n\n\n","category":"function"},{"location":"#RangeHelpers.bincenters-Tuple{AbstractRange}","page":"Home","title":"RangeHelpers.bincenters","text":"bincenters(r::AbstractRange)::AbstractRange\n\nIf r is interpreted as a collection of bin boundaries, bincenters returns the bin centers.\n\njulia> using RangeHelpers: bincenters\n\njulia> bincenters(1:10.0)\n1.5:1.0:9.5\n\nSee also binwalls.\n\n\n\n\n\n","category":"method"},{"location":"#RangeHelpers.binwalls-Tuple{AbstractRange}","page":"Home","title":"RangeHelpers.binwalls","text":"binwalls(r::AbstractRange; first=true, last=true)::AbstractRange\n\nIf r is interpreted as a collection of bin centers, binwalls returns the bin boundaries.\n\njulia> using RangeHelpers: binwalls\n\njulia> binwalls(0.0:2.0:10.0)\n-1.0:2.0:11.0\n\njulia> binwalls(0.0:2.0:10.0, first=false)\n1.0:2.0:11.0\n\njulia> binwalls(0.0:2.0:10.0, last=false)\n-1.0:2.0:9.0\n\nSee also bincenters.\n\n\n\n\n\n","category":"method"},{"location":"#RangeHelpers.prolong-Tuple{AbstractRange}","page":"Home","title":"RangeHelpers.prolong","text":"prolong(r::AbstractRange;start=nothing, stop=nothing, pre=nothing, post=nothing)\n\nProlong an existing range r according to the arguments:\n\njulia> using RangeHelpers\n\njulia> r = 1.0:0.5:3.0\n1.0:0.5:3.0\n\njulia> prolong(r, stop=around(4))\n1.0:0.5:4.0\n\njulia> prolong(r, pre=1)\n0.5:0.5:3.0\n\njulia> prolong(r, pre=1, post=2)\n0.5:0.5:4.0\n\njulia> prolong(r, start=below(0.4), stop=around(4.1))\n0.0:0.5:4.0\n\n\n\n\n\n","category":"method"},{"location":"#RangeHelpers.range","page":"Home","title":"RangeHelpers.range","text":"range(start, stop; length, step)\nrange(start; stop, length, step)\nrange(;start, stop, length, step)\n\nConstruct a range from the arguments. Three arguments must be given.\n\njulia> using RangeHelpers\n\njulia> using RangeHelpers: range\n\njulia> range(start=1, stop=3, length=3)\n1.0:1.0:3.0\n\njulia> range(start=1, stop=3.1, step=around(1))\n1.0:1.05:3.1\n\njulia> range(start=1, stop=around(3.1), step=1)\n1:1:3\n\njulia> range(start=1, stop=above(3.1), step=1)\n1:1:4\n\njulia> range(start=1, stop=above(3.0), step=1)\n1:1:3\n\njulia> range(start=around(0.9), stop=3.0, step=1)\n1.0:1.0:3.0\n\njulia> range(start=strictbelow(1.0), stop=3.0, step=1)\n0.0:1.0:3.0\n\nSee also the docs of Base.range.\n\n\n\n\n\n","category":"function"},{"location":"#RangeHelpers.samegrid-Tuple{AbstractRange, AbstractRange}","page":"Home","title":"RangeHelpers.samegrid","text":"samegrid(r1::AbstractRange, r2::AbstractRange; atol=0, rtol=0, kw...)::Bool\n\nCheck if r1 and r2 are defined on the same grid. That is if there exist equal prolongations of r1 and r1.\n\njulia> using RangeHelpers: samegrid\n\njulia> samegrid(1:10, 11:12)\ntrue\n\njulia> samegrid(1:10, 11:1.1:12)\nfalse\n\njulia> samegrid(1:10, 1:0)\ntrue\n\njulia> samegrid(1:10, 0.1:0)\nfalse\n\njulia> samegrid(1:10, 5:-1:3)\ntrue\n\njulia> samegrid(1:10, 4.1:1:5, rtol=0.2)\ntrue\n\n\n\n\n\n\n","category":"method"},{"location":"#RangeHelpers.searchsortedat-Tuple{Any, RangeHelpers.Approach}","page":"Home","title":"RangeHelpers.searchsortedat","text":"searchsortedat(coll, x)\n\nReturn the index of a sorted collection coll whose corresponding element is closest to x. If coll is not sorted, searchsortedat might silently return a wrong result.\n\njulia> using RangeHelpers\n\njulia> searchsortedat(100:100:1000, around(200))\n2\n\njulia> searchsortedat(100:100:1000, around(249))\n2\n\njulia> searchsortedat(100:100:1000, around(251))\n3\n\njulia> searchsortedat(100:100:1000, below(251))\n2\n\njulia> searchsortedat(100:100:1000, above(249))\n3\n\njulia> searchsortedat(100:100:1000, 300)\n3\n\njulia> searchsortedat(100:100:1000, 301)\nERROR: ArgumentError: coll does not contain x:\ncoll = 100:100:1000\nx = 301\nTry `searchsortedat(coll, around(x))`\n\n\n\n\n\n","category":"method"},{"location":"#RangeHelpers.subdivide-Tuple{AbstractRange, Integer}","page":"Home","title":"RangeHelpers.subdivide","text":"subdivide(r::AbstractRange, factor::Integer, mode=:walls)\n\nCreate a range with smaller step from r. Possible values for mode are (:walls, :centers).\n\njulia> using RangeHelpers\n\njulia> r = 1:3.0\n1.0:1.0:3.0\n\njulia> subdivide(r, 2)\n1.0:0.5:3.0\n\njulia> subdivide(r, 4)\n1.0:0.25:3.0\n\njulia> subdivide(r, 2, mode=:walls)\n1.0:0.5:3.0\n\njulia> subdivide(r, 2, mode=:centers)\n0.75:0.5:3.25\n\njulia> subdivide(r, 10, mode=:centers)\n0.55:0.1:3.45\n\n\n\n\n\n","category":"method"},{"location":"#RangeHelpers.symrange-Tuple{}","page":"Home","title":"RangeHelpers.symrange","text":"symrange(;center=0, step, length, start, stop)\n\nConstruct a range, that is symmetric around center.\n\njulia> using RangeHelpers\n\njulia> symrange(length=2, step=1)\n-0.5:1.0:0.5\n\njulia> symrange(length=3, step=1)\n-1.0:1.0:1.0\n\njulia> symrange(length=3, step=1, center=4)\n3.0:1.0:5.0\n\njulia> symrange(start=around(-4.1), step=2)\n-4.0:2.0:4.0\n\njulia> symrange(start=around(-4.1), step=2, center=1)\n-4.0:2.0:6.0\n\njulia> symrange(stop=around(4.1), step=2, center=1)\n-2.0:2.0:4.0\n\n\n\n\n\n","category":"method"}]
}
